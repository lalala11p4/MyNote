一.SpringCloud

##### 1.SpringCloud面试题

	1）什么是微服务
	
	2）微服务之间是如何独立通信的
	
	3）Springcloud和Dubbo有哪些区别
	
	4）SpringBoot和SpringCloud，谈一谈对他们的理解
	
	5）什么是服务熔断，服务降级
	
	6）微服务的优缺点是什么，说一下在项目开发中遇到的坑
	
	7）你所知道的微服务的技术栈有哪些
	
	8）eureka和zokeeper都可以提供服务注册和发现的功能，请说说两个的区别

##### 2.微服务概述

​	微服务定义网址 >https://martinfowler.com/articles/microservices.html

​	微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底
地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，
从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动
或销毁，拥有自己独立的数据库。

![image-20191216101433721](%E4%B8%80.SpringCloud.assets/image-20191216101433721.png)

###### 1）微服务和微服务架构

​	微服务强调的是服务的大小，他关注的是一个点，视具体解决一个问题或提供落地对应服务的一个服务应用，可以看做Eclipse里面的一个个微服务工程或者Module

​	微服务架构是一种架构模式，他提倡将单一应用程序划分成一组小的服务服务之间互相协调，互相配合，为用户提供接口调用，每个服务运行在独立的进程当中，服务和服务之间采用轻量级的通信机制互相协作（通常是基于HTTP协议的RESTFUL     API），每个服务都围绕具体业务进行构建，并且能够独立的部署到环境当中，另外，应当尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务的上下级模块，选择合适的语言工具对其构建模块

###### 2)微服务优缺点

​	**优点**

​	每个服务足够内聚，足够小，代码容易理解，能够聚焦一个指定的业务功能或业务需求

​	开发简单，开发效率提高，一个服务可能就是干专一的一件事，

​	微服务能够被小团队单独开发，这个小团队是2到5人

​	微服务是松耦合的，是有功能意义的服务，无论是开发还是部署阶段都是独立的

​	微服务能够使用不同的语言进行开发，

​	易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续的集成工具，如Jenkins，Hudson，bamboo

​	微服务允许利用融合最新技术

​	微服务只是业务逻辑的代码，并不会和HTML，Css或其他界面组件混合

​	每个微服务都有自己的存储能力，可以有自己的数据库也可以有统一的数据库

​	**缺点**

​	开发人员要处理分布式系统的复杂性

​	多服务运维难度加大

​	系统部署依赖

​	服务间通信成本

​	数据一致性

​	系统集成测试

​	性能监控

###### 3）涉及的技术栈

|     微服务条目      |           落地技术            |
| :-----------------: | :---------------------------: |
|      服务开发       |  Springboot,Spring,SpringMVC  |
|   服务配置和管理    |       Archaius,Diamond        |
|   服务注册与发现    |    Eureka,Consul,Zookeeper    |
|      服务调用       |         Rest,RPC,gRPC         |
|     服务熔断器      |         Hystrix,Envoy         |
|      负载均衡       |         Ribbon,Nginx          |
|    服务接口调用     |             feign             |
|      消息队列       |    Kafka,RabbitMQ,ActiveMQ    |
|  服务配置中心管理   |    SpringCloudConfig,Chef     |
| 服务路由（API网关） |             Zuul              |
|      服务监控       | Zabbix,Nagios,Metrics,Spector |

##### 3.选择SpringCloud的原因

​	SpringCloud是分布式微服务交古下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶

​	从四个维度考虑：

​		整体解决方案和框架的成熟度，社区热度，可维护性，学习曲线

​	目前各大公司使用的微服务架构有哪些：

​		阿里：Dubbo/HSF

​		京东：JSF

​		新浪微博：Motan

​		当当网：Dubbox

​	目前使用SpringCloud公司：

![image-20200228124457581](%E4%B8%80.SpringCloud.assets/image-20200228124457581.png)

​	阿里云使用SpringCloud

![image-20200228124558659](%E4%B8%80.SpringCloud.assets/image-20200228124558659.png)

###### 1）SpringCloud和SpringBoot的联系

​	SpringBoot专注于快速方便的开发单个个体微服务

​	SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，
为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务

​	SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系.

​	SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。

###### 2）SpringCloud和Dubbo的区别

​	目前较为成熟的互联网架构

![image-20200228123808656](%E4%B8%80.SpringCloud.assets/image-20200228123808656.png)

​	SpringCloud和Dubbo对比

|              |     Dubbo     |         SpringCloud          |
| :----------: | :-----------: | :--------------------------: |
| 服务注册中心 |   Zookeeper   | Spring Cloud Netflix Eureka  |
| 服务调用方式 |      RPC      |           Rest API           |
|   服务监控   | Dubbo-monitor |      Spring Boot Admin       |
|    断路器    |    不完善     | Spring Cloud Netflix Hystrix |
|   服务网关   |      无       |  Spring Cloud Netflix Zuul   |
|  分布式配置  |      无       |     Spring Cloud Config      |
|   服务跟踪   |      无       |     Spring Cloud Sleuth      |
|   消息总线   |      无       |       Spring Cloud Bus       |
|    数据流    |      无       |     Spring Cloud Stream      |
|   批量任务   |      无       |      Spring Cloud Task       |

​	最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。
​	严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。

​	品牌机与组装机的区别
​	很明显，Spring Cloud的功能比DUBBO更加强大，涵盖面更广，而且作为Spring的拳头项目，它也能够与Spring Framework、Spring Boot、Spring Data、Spring Batch等其他Spring项目完美融合，这些对于微服务而言是至关重要的。使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。

​	最为重要的是，DUBBO停止了5年左右的更新，虽然2017.7重启了。对于技术发展的新需求，需要由开发者自行拓展升级（比如当当网弄出了DubboX），这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的，中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案，并不是每一个公司都有阿里的大牛+真实的线上生产环境测试过。

> 中文网址文档：https://www.springcloud.cc/spring-cloud-netflix.html

> API中文文档地址：https://www.springcloud.cc/spring-cloud-dalston.html

> SpringCloud中国社区：https://springcloud.cn/
>
> SpringCloud中文网：https://springcloud.cc/image-20191216230024709

![image-20191216230024709](%E4%B8%80.SpringCloud.assets/image-20191216230024709.png)

##### 4.Rest微服务构建工程模块

​	新建父工程microservicecloud，主要是定义POM文件，将后续各个子模块公用的jar包等统一提出来，类似一个抽象父类，切记是Type是pom模式

![image-20200228130707609](%E4%B8%80.SpringCloud.assets/image-20200228130707609.png)

![image-20200228130809760](%E4%B8%80.SpringCloud.assets/image-20200228130809760.png)

​	引入pom文件

```pom
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
 
  <groupId>com.atguigu.springcloud</groupId>
  <artifactId>microservicecloud</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>pom</packaging>
 
 
  <properties>
   <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
   <maven.compiler.source>1.8</maven.compiler.source>
   <maven.compiler.target>1.8</maven.compiler.target>
   <junit.version>4.12</junit.version>
   <log4j.version>1.2.17</log4j.version>
   <lombok.version>1.16.18</lombok.version>
  </properties>
 
  <dependencyManagement>
   <dependencies>
     <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-dependencies</artifactId>
       <version>Dalston.SR1</version>
       <type>pom</type>
       <scope>import</scope>
     </dependency>
     <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-dependencies</artifactId>
       <version>1.5.9.RELEASE</version>
       <type>pom</type>
       <scope>import</scope>
     </dependency>
     <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>5.0.4</version>
     </dependency>
     <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>druid</artifactId>
       <version>1.0.31</version>
     </dependency>
     <dependency>
       <groupId>org.mybatis.spring.boot</groupId>
       <artifactId>mybatis-spring-boot-starter</artifactId>
       <version>1.3.0</version>
     </dependency>
     <dependency>
       <groupId>ch.qos.logback</groupId>
       <artifactId>logback-core</artifactId>
       <version>1.2.3</version>
     </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <version>${junit.version}</version>
       <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>log4j</groupId>
       <artifactId>log4j</artifactId>
       <version>${log4j.version}</version>
     </dependency>
   </dependencies>
  </dependencyManagement>
</project>
```

​	新建microservicecloud-api公共子模块（maven工程，父工程为microservicecloud），添加依赖

```pom
<dependencies><!-- 当前Module需要用到的jar包，按自己需求添加，如果父类已经包含了，可以不用写版本号 -->
   <dependency>
     <groupId>org.projectlombok</groupId>
     <artifactId>lombok</artifactId>
   </dependency>
  </dependencies>
```

​	新建部门实体类Dept

```java
@SuppressWarnings("serial")
@NoArgsConstructor
@Data
@Accessors(chain=true)
public class Dept {
    private Long  deptno;   //主键
    private String  dname;   //部门名称
    private String  db_source;//来自那个数据库，因为微服务架构可以一个服务对应一个数据库，同一个信息被存储到不同数据库

    public Dept(String dname)
    {
        super();
        this.dname = dname;
    }
}
```

![image-20200228144757602](%E4%B8%80.SpringCloud.assets/image-20200228144757602.png)

​	新建microservicecloud-provider-dept-8001服务提供者模块，pom文件

```xml
<dependencies>
        <dependency>
        <!-- 引入自己定义的api模块的内容，可以使用Dept部门Entity -->
            <groupId>com.springcloud</groupId>
            <artifactId>microservicecloud-api</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jetty</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>
        <!-- 修改后立即生效，热部署 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>springloaded</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
        </dependency>
    </dependencies>
```

![image-20200228145428015](%E4%B8%80.SpringCloud.assets/image-20200228145428015.png)

​	配置provider-dept-8001模块的yml文件

```yml
server:
  port: 8001

mybatis:
  config-location: classpath:mybatis/mybatis.cfg.xml        # mybatis配置文件所在路径
  type-aliases-package: com.sinosoft.springcloud.Entities    # 所有Entity别名类所在包
  mapper-locations:
  - classpath:mybatis/mapper/**/*.xml                       # mapper映射文件

spring:
   application:
    name: microservicecloud-dept                            # 对外暴露的微服务名字
   datasource:
    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型
    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包
    url: jdbc:mysql://localhost:3306/cloudDB01             # 数据库名称
    username: root
    password: 123456789
    dbcp2:
      min-idle: 5                                           # 数据库连接池的最小维持连接数
      initial-size: 5                                       # 初始化连接数
      max-total: 5                                          # 最大连接数
      max-wait-millis: 200                                  # 等待连接获取的最大超时时间
```

​	整合Mybatis内容

![image-20200228152036702](%E4%B8%80.SpringCloud.assets/image-20200228152036702.png)

![image-20200228152051935](%E4%B8%80.SpringCloud.assets/image-20200228152051935.png)

​	在mysql数据库中，新建dept表与之yml文件相对应

![image-20200228152201270](%E4%B8%80.SpringCloud.assets/image-20200228152201270.png)

​	编写controller内容

```java
@RestController
public class DeptController {
    
    @Autowired
    private DeptService deptService;

    @RequestMapping(value = "/dept/add",method = RequestMethod.POST)
    public Boolean add(@RequestBody Dept dept){
        return deptService.add(dept);
    }
    
    @RequestMapping(value = "/dept/get/{id}", method = RequestMethod.GET)
    public Dept get(@PathVariable("id") Long id)
    {
        return deptService.get(id);
    }
    
    @RequestMapping(value = "/dept/list", method = RequestMethod.GET)
    public List<Dept> list()
    {
        return deptService.list();
    }
}
```

​	编写主启动类，启动测试

```java
@SpringBootApplication
public class DeptProvider8001_App {

    public static void main(String[] args) {
        SpringApplication.run(DeptProvider8001_App.class,args);
    }
}
```

​	启动成功，进行验证

![image-20200228153549989](%E4%B8%80.SpringCloud.assets/image-20200228153549989.png)

​	验证成功！提供者模块构建成功



​	新建microservicecloud-consumer-dept-80消费者模块，是请求的发起者，添加pom依赖

```xml
<dependencies>
   <dependency><!-- 自己定义的api -->
     <groupId>com.springcloud</groupId>
     <artifactId>microservicecloud-api</artifactId>
     <version>${project.version}</version>
   </dependency> 
   <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   <!-- 修改后立即生效，热部署 -->
   <dependency>
     <groupId>org.springframework</groupId>
     <artifactId>springloaded</artifactId>
   </dependency>
   <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-devtools</artifactId>
   </dependency>   
  </dependencies>
```

​	配置文件内容(仅仅定义端口信息)

```yml
server:
  port: 80
```

​	com.sinosoft.springcloud.cfgbeans包下ConfigBean的编写（类似spring里面的applicationContext.xml写入的注入Bean），向Spring容器中注入RestTemplate实例Bean

```java
@Configuration  //boot -->  配置类
public class ConfigBean {
    @Bean
    public RestTemplate getRestTemple(){
        return new RestTemplate();
    }
}
```

​	RestTemplate介绍：

​	RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集

​		官网地址

​		https://docs.spring.io/spring-framework/docs/4.3.7.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html

​		使用
​		使用restTemplate访问restful接口非常的简单粗暴无脑。(url, requestMap, ResponseBean.class)这三个参数分别代表REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。

​		新建Controller

```java
@RestController
public class DeptController_Consumer {
    @Autowired
    private RestTemplate restTemplate;

    private static final String REST_URL_PREFIX = "http://localhost:8001";
    /**
     * RestTemplate提供了多种便捷访问远程HTTP服务的方法
     * 是一种简单快捷的访问restful服务模板类
     * 是Spring提供的用于访问Rest服务的客户端模板工具集
     *
     * 使用restTemple访问restful接口非常简单粗暴无脑
     *
     * (url,requestMap,ResponseBean.class)
     *
     * 这三个参数代表
     *
     * REST请求地址，请求参数，HTTP响应转换被转换成的对象类型
     */

    @RequestMapping(value = "/consumer/dept/add")
    public boolean add(Dept dept){

        return restTemplate.postForObject(REST_URL_PREFIX+"/dept/add",dept,Boolean.class);

    }

    @RequestMapping(value = "/consumer/dept/get/{id}")
    public Dept get(@PathVariable("id") Long id){

        return restTemplate.getForObject(REST_URL_PREFIX+"/dept/get/"+id,Dept.class);

    }

    @RequestMapping(value = "/consumer/dept/list")
    public List<Dept> get(){
        return restTemplate.getForObject(REST_URL_PREFIX+"/dept/list",List.class);
    }

}
```

​	测试RestTemplate远程调用服务生产者

​	启动80和8001两个子模块

![image-20200228155358537](%E4%B8%80.SpringCloud.assets/image-20200228155358537.png)

![image-20200228155430264](%E4%B8%80.SpringCloud.assets/image-20200228155430264.png)

​	页面调用

![image-20200228155548266](%E4%B8%80.SpringCloud.assets/image-20200228155548266.png)

​	远程调用成功！

##### 5.Eureka服务注册和发现（重中之重）

###### 1）Eureka介绍

​	Eureka是Netflix的一个子模块，也是核心模块之一。Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。

​	服务注册与发现对于微服务架构来说是非常重要的，有了服务发现与注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了。功能类似于dubbo的注册中心，比如Zookeeper。

​	Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。

​	而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。SpringCloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。

![image-20200228160636337](%E4%B8%80.SpringCloud.assets/image-20200228160636337.png)

​	Eureka包含两个组件：Eureka Server和Eureka Client

​	Eureka Server提供服务注册服务
​	各个节点启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到


​	EurekaClient是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）

###### 2）构建Eureka集群

​	新建microservicecloud-eureka-7001子模块

![image-20200228161128783](%E4%B8%80.SpringCloud.assets/image-20200228161128783.png)

​	pom文件添加依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>microservicecloud</artifactId>
        <groupId>com.sinosoft.springcloud</groupId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../microservicecloud/pom.xml</relativePath>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>microservicecloud-eureka-7001</artifactId>
    <dependencies>
        <!--eureka-server服务端 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-eureka-server</artifactId>
        </dependency>
        <!-- 修改后立即生效，热部署 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>springloaded</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
        </dependency>
    </dependencies>

</project>
```

​	基本上引入一个cloud的新技术组件，需要两步

​		1.新增一个相关的组件依赖在pom文件中

​		2.在主启动类上添加开启新组件的注解

​	在yml配置文件中添加eureka内容

```yml
server:
  port: 7001

eureka:
  instance:
    hostname: localhost #eureka服务端的实例名称
  client:
    register-with-eureka: false     #false表示不向注册中心注册自己。
    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    service-url:
    defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

​	在主启动类上添加注解

```java
@SpringBootApplication
@EnableEurekaServer  //EurekaServer 服务器启动类，接收其他为服务注册进来
public class EurekaServer7001_App {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServer7001_App.class,args);
    }
}
```

​	启动并测试

![image-20200228162317462](%E4%B8%80.SpringCloud.assets/image-20200228162317462.png)

![image-20200228162421762](%E4%B8%80.SpringCloud.assets/image-20200228162421762.png)

​	一个Eureka完成，目前没有服务注册进来，

###### 3)注册进Eureka当中	

​	将microservicecloud-provider-dept-8001服务的提供者注册进Eureka当中

​	在pom文件新增依赖信息

```xml
<dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-eureka</artifactId>
   </dependency>
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-config</artifactId>
   </dependency>

```

​	在配置文件中新加入eureka内容

```yml
eureka:
  client: #客户端注册进eureka服务列表内
    service-url: 
      defaultZone: http://localhost:7001/eureka #注册地址和eureka相同
```

​	在8001主启动类上开启注解，表明身份，我是客户端（@EnableEurekaClient），而7001的Eureka实例注解为@EnableEurekaServer，表明自己是服务端

```java
@SpringBootApplication
@EnableEurekaClient//本服务在启动之后会自动注册euraka服务中
public class DeptProvider8001_App {

    public static void main(String[] args) {
        SpringApplication.run(DeptProvider8001_App.class,args);
    }
}
```

​	先启动Eureka服务端，再启动客户端，看是否Eureka接收到注册信息

![image-20200228164110925](%E4%B8%80.SpringCloud.assets/image-20200228164110925.png)

​	8001已经成功注册进7001Eureka当中，成功

​	这个注册进Eureka的服务名字为8001的spring服务名字，默认大写

![image-20200228164344156](%E4%B8%80.SpringCloud.assets/image-20200228164344156.png)

###### 4）actuator注册信息完善

​	在8001客户端添加配置信息

```yml
eureka:
  client: #客户端注册进eureka服务列表内
    service-url:
      defaultZone: http://localhost:7001/eureka
  instance:
    instance-id: microservicecloud-dept8001	# 用自己定义的服务名进行替换
    prefer-ip-address: true     #访问路径可以显示IP地址

info:
  app.name: sinosoft-microservicecloud # 点击显示的详细信息
  company.name: www.sinosoft.com
  build.artifactId: $project.artifactId$
  build.version: $project.version$
```

在8001的pom文件添加依赖

```xml
 <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-actuator</artifactId>
   </dependency>
```

![image-20200228165421646](%E4%B8%80.SpringCloud.assets/image-20200228165421646.png)

​	从服务名中点击进去会显示具体信息

![image-20200228165456781](%E4%B8%80.SpringCloud.assets/image-20200228165456781.png)

###### 5)Eureka自我保护

​	![image-20200228201453834](%E4%B8%80.SpringCloud.assets/image-20200228201453834.png)

![image-20200228201503701](%E4%B8%80.SpringCloud.assets/image-20200228201503701.png)

​	在启动并注册进入Eureka之后，8001的服务名称发生了变动，Eureka并不会清除之前的服务信息，而是会保留之前的信息，并发出红字提醒，一句话：某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存

​	默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。

​	综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留），也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。

​	在Spring Cloud中，可以使用eureka.server.enable-self-preservation = false 禁用自我保护模式。

###### 6）Eureka的服务发现

​	对于注册进Eureka里面的微服务，可以通过服务发现来获得该服务的信息

​	修改provider-8001的DeptController，添加以下代码

```java
/**
 * 存在多个Bean实例的话，可以使用@Qualifier来指定
 * 要注入的Bean实例对象
 */
@Autowired
@Qualifier("discoveryClient")
private DiscoveryClient client;

@RequestMapping(value = "/dept/discovery", method = RequestMethod.GET)
@Transactional
public Object discovery(){
    List<String> list = client.getServices();
    System.out.println("**********" + list);

    List<ServiceInstance> srvList = client.getInstances("MICROSERVICECLOUD-DEPT");
    for (ServiceInstance element : srvList) {
        System.out.println(element.getServiceId() + "\t" + element.getHost() + "\t" + element.getPort() + "\t"
                           + element.getUri());
    }
    return this.client;
}
```

​	主启动类添加服务发现注解

```java
@SpringBootApplication
@EnableEurekaClient//本服务在启动之后会自动注册euraka服务中
@EnableDiscoveryClient//服务发现
public class DeptProvider8001_App {
	public static void main(String[] args) {
        SpringApplication.run(DeptProvider8001_App.class,args);
    }
}
```

​	启动测试，先启动Eureka7001，再启动DeptProvider8001 主启动类，访问地址：

​	localhost：8001/dept/discovery

![image-20200228204233642](%E4%B8%80.SpringCloud.assets/image-20200228204233642.png)

![image-20200228204245276](%E4%B8%80.SpringCloud.assets/image-20200228204245276.png)

​	通过服务发现，可以方便快捷的定位各个服务信息

###### 7）Eureka集群配置

​	新建microservicecloud-eureka-7002/microservicecloud-eureka-7003	

​	修改7002和7003的主启动类

​	找到C:\Windows\System32\drivers\etc路径下的hosts文件修改域名映射

​		127.0.0.1  eureka7001.com

​		127.0.0.1  eureka7002.com

​		127.0.0.1  eureka7003.com

​	修改7001,7002,7003的yml文件

```yml
server: 
  port: 7001
 
eureka: 
  instance:
    hostname: eureka7001.com #eureka服务端的实例名称
  client: 
    register-with-eureka: false     #false表示不向注册中心注册自己。
    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    service-url: 
      #单机 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/       #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。
      defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/
```

```yml
server: 
  port: 7002
 
eureka: 
  instance:
    hostname: eureka7002.com #eureka服务端的实例名称
  client: 
    register-with-eureka: false     #false表示不向注册中心注册自己。
    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    service-url: 
      #defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/       #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7003.com:7003/eureka/
```

```yml
server: 
  port: 7003
 
eureka: 
  instance:
    hostname: eureka7003.com #eureka服务端的实例名称
  client: 
    register-with-eureka: false     #false表示不向注册中心注册自己。
    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    service-url: 
      #defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/       #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/
```

​	修改8001工程配置文件，使其注册进入三个Rureka当中

```yml
eureka:
  client: #客户端注册进eureka服务列表内
    service-url: 
      defaultZone:   http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/    #注册进入三台Eureka当中
  instance:
    instance-id: microservicecloud-dept8001   #自定义服务名称信息
    prefer-ip-address: true     #访问路径可以显示IP地址
      
info:
  app.name: atguigu-microservicecloud
  company.name: www.atguigu.com
  build.artifactId: $project.artifactId$
  build.version: $project.version$
```

​	验证启动，启动3台Eureka，在启动8001项目

![image-20200228210625364](%E4%B8%80.SpringCloud.assets/image-20200228210625364.png)

![image-20200228210651676](%E4%B8%80.SpringCloud.assets/image-20200228210651676.png)

​	集群搭建成功

###### 8）Eureka比Zookeeper好在哪里

​	CAP理论指出，一个分布式系统不可能同时满足C（一致性），A（可用性），P（分区容错性），由于分区容错性P是分布式系统中必须要保证的，因此我们必须要在A和C之间做出取舍

​	Zookeeper保证的是CP，Eureka保证的是AP

​	当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟之前的注册信息，但是不能接受服务直接down掉不可用，也就是说，服务注册功能对可用性的要求要高于一致性，Zookeeper会出现一种情况，当master节点因为网络故障和其他节点失去联系时，剩余节点会重新进行leader选举，问题在于，选举的leader时间较长，30~120s，并且选举期间整个zk集群是不可用的，这就导致在选举期间注册服务瘫痪，在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期比可用是不能够容忍的

​	Eureka在设计时就优先保证可用性，Eureka各个节点都是平等的吗，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务，而Eureka的客户端再向某个Eureka注册或者如果发生连接失败，则会自动切换到其他的节点上，只要有一台的Eureka存在，就能够保证注册服务可用，只不过查到的信息可能不是最新的（不保证强一致性）。

​	除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点没有正常的心跳，那么Eureka就认为客户端和注册中心出现了网络故障，此时会出现以下几种情况：

​		1.Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务

​		2.Eureka仍然能够接收新的服务注册和查询请求，但是不会同步到其他节点上（保证当前的节点依然可用）

​		3.当网络稳定时，当前实例新的注册信息会被同步到其他节点中

##### 6.Ribbon负载均衡

​	Spring Cloud Ribbon是基于Netflix Ribbon实现的一套**客户端**负载均衡的工具。

​	简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。

​	LB，即负载均衡(Load Balance)，在微服务或分布式集群中经常用的一种应用。
负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA。
常见的负载均衡有软件Nginx，LVS，硬件 F5等。
相应的在中间件，例如：dubbo和SpringCloud中均给我们提供了负载均衡，SpringCloud的负载均衡算法可以自定义。 

​	集中式LB

​	即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；集中式LB

​	即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；

​	进程内LB

​	将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。

​	Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。

###### 1）Ribbon配置初步

​	修改microservicecloud-consumer-dept-80工程,新增pom依赖

```xml
<!-- Ribbon相关 -->
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-eureka</artifactId>
   </dependency>
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-ribbon</artifactId>
   </dependency>
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-config</artifactId>
   </dependency>

```

​	配置文件yml新增内容：

```yml
eureka:
  client:
    register-with-eureka: false
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/
```

![image-20200228225536471](%E4%B8%80.SpringCloud.assets/image-20200228225536471.png)

​	对ConfigBean进行新注解@LoadBalanced,实现负载均衡，获得Rest时加入Ribbon的配置

```java
@Configuration  //boot -->  配置类
public class ConfigBean {
    @Bean
    @LoadBalanced//SpringCloud Ribbon是基于Netflix实现的一套客户端负载均衡工具
    public RestTemplate getRestTemple(){
        return new RestTemplate();
    }
}
```

​	主启动类添加开启访问Eureka的注解

```java
@SpringBootApplication
@EnableEurekaClient
public class DeptConsumer80_App {
    public static void main(String[] args) {
        SpringApplication.run(DeptConsumer80_App.class,args);
    }
}
```

​	修改Controller访问的IP加端口，改为Eureka中注册的微服务名字

```java
@RestController
public class DeptController_Consumer {

    //private static final String REST_URL_PREFIX = "http://localhost:8001";
    //使用Eureka中注册的微服务名字
    private static final String REST_URL_PREFIX = "http://MICROSERVICECLOUD-DEPT";
```

​	启动测试，先启动7001,7002,7003，在启动8001,80进行测试

![image-20200228230713337](%E4%B8%80.SpringCloud.assets/image-20200228230713337.png)

![image-20200228230735281](%E4%B8%80.SpringCloud.assets/image-20200228230735281.png)

​	访问成功！

###### 2）Ribbon负载均衡

​	![image-20200228231038184](%E4%B8%80.SpringCloud.assets/image-20200228231038184.png)

​	Ribbon在工作时分成两步
​	第一步先选择 EurekaServer ,它优先选择在同一个区域内负载较少的server.
​	第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。
其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。

​	参照8001新建8002，,8003模块，连接不同数据库![image-20200228231249555](%E4%B8%80.SpringCloud.assets/image-20200228231249555.png)

![image-20200228231323459](%E4%B8%80.SpringCloud.assets/image-20200228231323459.png)

​	8001,8002,8003模块连接不同的数据库

​	启动测试，先启动三台Eureka，在启动三台8001并自测

![image-20200228231859596](%E4%B8%80.SpringCloud.assets/image-20200228231859596.png)

![image-20200228231912770](%E4%B8%80.SpringCloud.assets/image-20200228231912770.png)

​	启动80消费者模块

![image-20200228232045552](%E4%B8%80.SpringCloud.assets/image-20200228232045552.png)

​	演示负载均衡

​	http://localhost/consumer/dept/list

![image-20200228232152483](%E4%B8%80.SpringCloud.assets/image-20200228232152483.png)

![image-20200228232221696](%E4%B8%80.SpringCloud.assets/image-20200228232221696.png)

![image-20200228232210315](%E4%B8%80.SpringCloud.assets/image-20200228232210315.png)

​	每次访问都是用了Ribbon的默认的轮询算法，每次访问不同的底层数据库

​	Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。

###### 3）Ribbon的核心组件IRule

​	IRule：根据特定的算法从服务列表中选取一个要访问的服务

​	IRule本地出场自带7种算法

![image-20200229104304027](%E4%B8%80.SpringCloud.assets/image-20200229104304027.png)

​	默认是使用自带的轮询算法，现在切换为随机算法

​	在消费者客户端的ConfigBean中添加随机算法的Bean实例，即可使用随机算法替代轮询算法

```java
@Bean
public IRule myRule(){
    //用重新选择的随机算法替代默认的轮询算法
    return new RandomRule();
}
```

​	添加之后负载均衡算法成功被切换为随机算法

​	使用自己定义的算法进行负载均衡

​	首先在主配置类上添加RibbonClient注解

```java
@SpringBootApplication
@EnableEurekaClient
//新添加注解
@RibbonClient(name = "MICROSERVICECLOUD-DEPT",configuration = RnadomRule_ZY.class)  //name = "MICROSERVICECLOUD-DEPT" 针对于这个微服务实例，configuration = RnadomRule_ZY.class  使用的配置算法为这个配置类  
public class DeptConsumer80_App {
    public static void main(String[] args) {
        SpringApplication.run(DeptConsumer80_App.class,args);
    }
}
```

![image-20200229110535229](%E4%B8%80.SpringCloud.assets/image-20200229110535229.png)

​	**注意**：官网文档明确给出了警告，自定义配置类不能够放在@ComponentScan所扫描的当前包及其子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端共享，达不到特殊定制化的目的

![image-20200229110743813](%E4%B8%80.SpringCloud.assets/image-20200229110743813.png)

```txt
//Github网站规则实例网址
> https://github.com/Netflix/ribbon/blob/master/ribbon-loadbalancer/src/main/java/com/netflix/loadbalancer/RandomRule.java
```

​	也就是说，配置类不能放在com.sinosoft.cloud下，新建包放置配置类

![image-20200229111050142](%E4%B8%80.SpringCloud.assets/image-20200229111050142.png)

​	自定义规则：依旧使用轮询策略，但是加上新的需求，每个服务器被调用5次，在轮询到下一台机器

![image-20200229111939367](%E4%B8%80.SpringCloud.assets/image-20200229111939367.png)

​	首先了解原始的随机算法如何实现：

```java
package com.netflix.loadbalancer;
import com.netflix.client.config.IClientConfig;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
public class RandomRule extends AbstractLoadBalancerRule {
 	//最主要的方法
    @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE") 
    public Server choose(ILoadBalancer lb, Object key) {
        if (lb == null) {
            return null;
        }
        Server server = null;

        while (server == null) {
            if (Thread.interrupted()) {
                return null;
            }
            //获取所有服务的集合
            List<Server> upList = lb.getReachableServers();
            List<Server> allList = lb.getAllServers();

            int serverCount = allList.size();
            if (serverCount == 0) {
                return null;
            }
		   //服务的大小作为参数，传入方法，返回一个小于大小的随机数
            int index = chooseRandomInt(serverCount);
            server = upList.get(index);

            if (server == null) {
                Thread.yield();
                continue;
            }
		   //如果这个服务是可用的，那么返回
            if (server.isAlive()) {
                return (server);
            }
            server = null;
            Thread.yield();
        }
	    //随机算法结束
        return server;

    }
    protected int chooseRandomInt(int serverCount) {
        return ThreadLocalRandom.current().nextInt(serverCount);
    }
	@Override
	public Server choose(Object key) {
		return choose(getLoadBalancer(), key);
	}
}
```

​	编写自己的配置类

```java
@Configuration
public class RnadomRule_ZY {

    @Bean
    public IRule myPrivateRule(){
        //用重新选择的随机算法替代默认的轮询算法
        return new MyRule();
    }
}
```

```java
//实现上层接口，并返回到实例当中
public class MyRule extends AbstractLoadBalancerRule{
    /**
     * 依旧使用轮询策略，加上新的需求，每个服务器要被调用5次
     * 轮询的时候是每台机器被调用一次，现在是每台机器被调用5次
     */
    //总共被调用的次数，目前要求每台被调用5次
    private int total = 0;
    //当前提供服务的机器号
    private int currentIndex = 0;

    @Override
    public Server choose(Object key) {
        return choose(getLoadBalancer(),key);
    }

    @Override
    public void initWithNiwsConfig(IClientConfig iClientConfig) {

    }
    protected int chooseRandomInt(int serverCount) {
        return ThreadLocalRandom.current().nextInt(serverCount);
    }


    public Server choose(ILoadBalancer lb, Object key){
        if (lb == null) {
            return null;
        }
        Server server = null;

        while (server == null) {
            if (Thread.interrupted()) {
                return null;
            }
            List<Server> upList = lb.getReachableServers();
            List<Server> allList = lb.getAllServers();

            int serverCount = allList.size();
            if (serverCount == 0) {
                return null;
            }
//            int index = chooseRandomInt(serverCount);
//            server = upList.get(index);
            if (total < 5){
                //总共被调用次数小于5，还是返回当前的server
                server = upList.get(currentIndex);
                total++;
            }else {
                //大于5就返回下一个server
                total = 0;
                currentIndex++;
                if (currentIndex>=upList.size()){
                    //超过了服务器个数则进行从头循环
                    currentIndex = 0;
                }
            }
            if (server == null) {
                Thread.yield();
                continue;
            }

            if (server.isAlive()) {
                return (server);
            }
            server = null;
            Thread.yield();
        }
        return server;
    }
}
```

​	编写完成，先起Eureka，再起peovider，最后起80，测试

​	第一次访问

![image-20200229130001121](%E4%B8%80.SpringCloud.assets/image-20200229130001121.png)

​	点击5次都是01数据库，点击第5下换为02数据库

![image-20200229125952379](%E4%B8%80.SpringCloud.assets/image-20200229125952379.png)

​	自定义负载算法完成！

##### 7.Feign负载均衡

​	官网描述：http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feign

​	Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单, 它的使用方法是定义一个接口，然后在上面添加注解，同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。

​	 Feign是一个声明式的Web服务客户端，使得编写Web服务客户端变得非常容易，
​	只需要创建一个接口，然后在上面添加注解即可。
​	参考官网：https://github.com/OpenFeign/feign 

###### 1）为什么存在Feign

​	目前绝大多数的程序员习惯于面向接口编程，比如WebService接口，我们是用微服务的名字进行地址调用，并且通过接口加上注解，可以调用我们的服务，为了适应社区其他程序员提出的，还是为了能够统一的面向接口编程的策略，出现了Feign

​	Feign能干什么
​	Feign旨在使编写Java Http客户端变得更容易。
​	前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。

###### 2）新建工程模块microservicecloud-consumer-dept-feign使用Feign

​	修改主启动类名字，添加pom依赖

```xml
 <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-feign</artifactId>
 </dependency>
```

​	去除多余主配置类注解

```java
@SpringBootApplication
@EnableEurekaClient
public class DeptConsumer_80_feign {
    public static void main(String[] args) {
        SpringApplication.run(DeptConsumer_80_feign.class,args);
    }
}
```

​	修改microservicecloud-api工程,添加pom依赖

```xml
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-feign</artifactId>
   </dependency>
```

​	新建DeptClientService接口并新增注解@FeignClient

```java
@FeignClient(value = "MICROSERVICECLOUD-DEPT")
public interface DeptClientService
{
  @RequestMapping(value = "/dept/get/{id}",method = RequestMethod.GET)
  public Dept get(@PathVariable("id") long id);
 
  @RequestMapping(value = "/dept/list",method = RequestMethod.GET)
  public List<Dept> list();
 
  @RequestMapping(value = "/dept/add",method = RequestMethod.POST)
  public boolean add(Dept dept);
}
```

​	回到microservicecloud-consumer-dept-feign工程修改Controller，对接上一步新建的DeptClientService接口（原有的使用RestTemplte不再使用）

```java
@RestController
public class DeptController_Feign
{
  @Autowired
  private DeptClientService service = null;
 
  @RequestMapping(value = "/consumer/dept/get/{id}")
  public Dept get(@PathVariable("id") Long id)
  {
   return this.service.get(id);
  }
 
  @RequestMapping(value = "/consumer/dept/list")
  public List<Dept> list()
  {
   return this.service.list();
  }
 
  @RequestMapping(value = "/consumer/dept/add")
  public Object add(Dept dept)
  {
   return this.service.add(dept);
  }
}
```

​	在microservicecloud-consumer-dept-feign主启动类添加注解

```java
@SpringBootApplication
@EnableEurekaClient
//新加两个注解
@EnableFeignClients(basePackages= {"com.atguigu.springcloud"})
@ComponentScan("com.atguigu.springcloud")
public class DeptConsumer80_Feign_App
{
  public static void main(String[] args)
  {
   SpringApplication.run(DeptConsumer80_Feign_App.class, args);
  }
}
```

​	启动进行测试，由于Feign已经集成了Ribbon，随意默认使用的也是轮询算法

![image-20200229144148668](%E4%B8%80.SpringCloud.assets/image-20200229144148668.png)

![image-20200229144156238](%E4%B8%80.SpringCloud.assets/image-20200229144156238.png)

​	总结：Feign通过接口的方法调用Rest服务（之前是Ribbon+RestTemplate），该请求发送给Eureka服务器（http://MICROSERVICECLOUD-DEPT/dept/list）,通过Feign直接找到服务接口，由于在进行服务调用的时候融合了Ribbon技术，所以也支持负载均衡作用。

##### 8.断路器Hystrix

###### 1）介绍

​	复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。

![image-20200229144554139](%E4%B8%80.SpringCloud.assets/image-20200229144554139.png)

​	服务雪崩

​	多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.

​	对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。

​	Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。

​	“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。

​	官网介绍：https://github.com/Netflix/Hystrix/wiki/How-To-Use

###### 2）服务熔断（添加在服务端并不是客户端）

​	熔断机制是应对雪崩效应的一种微服务链路保护机制。
​	当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回"错误"的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。

​	参考microservicecloud-provider-dept-8001，新建microservicecloud-provider-dept-hystrix-8001

​	新增pom依赖

```xml
   <!--  hystrix -->
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-hystrix</artifactId>
   </dependency>
```

​	修改配置文件

```yml
eureka:
  client: #客户端注册进eureka服务列表内
    service-url:
      #defaultZone: http://localhost:7001/eureka
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/
  instance:
    instance-id: microservicecloud-dept8001-hystrix  #自定义hystrix相关的服务名称信息，仅仅修改这个信息
    prefer-ip-address: true     #访问路径可以显示IP地址
```

![image-20200229145435389](%E4%B8%80.SpringCloud.assets/image-20200229145435389.png)

​	修改DeptController，一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法

```java
@RestController
public class DeptController
{
    @Autowired
    private DeptService service = null;

    @RequestMapping(value = "/dept/get/{id}", method = RequestMethod.GET)
    //一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法
    @HystrixCommand(fallbackMethod = "processHystrix_Get")
    public Dept get(@PathVariable("id") Long id)
    {

        Dept dept = this.service.get(id);

        if (null == dept) {
            throw new RuntimeException("该ID：" + id + "没有没有对应的信息");
        }

        return dept;
    }

    public Dept processHystrix_Get(@PathVariable("id") Long id)
    {
        Dept dept = new Dept();
        dept.setDeptno(id);
        dept.setDname("该ID：" + id + "没有没有对应的信息,null--@HystrixCommand");
        dept.setDb_source("no this database in MySQL");
        return dept;
    }
}
```

​	主启动类添加注解EnableCircuitBreaker//对hystrixR熔断机制的支持

```java
@SpringBootApplication
@EnableEurekaClient//本服务在启动之后会自动注册euraka服务中
@EnableDiscoveryClient//服务发现
@EnableCircuitBreaker//对hystrix熔断机制的支持
public class DeptProvider8001_hystrix_App {

    public static void main(String[] args) {
        SpringApplication.run(DeptProvider8001_hystrix_App.class,args);
    }
}
```

​	启动测试

![image-20200229151307173](%E4%B8%80.SpringCloud.assets/image-20200229151307173.png)

​	正常访问没有问题

![image-20200229151359131](%E4%B8%80.SpringCloud.assets/image-20200229151359131.png)

​	访问不存在的数据，返回了出现异常的信息

![image-20200229151420394](%E4%B8%80.SpringCloud.assets/image-20200229151420394.png)

​	熔断调用成功！

###### 3）服务降级

​	整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。

​	上面的服务熔断会在生产者的Controller中添加异常方法，会将异常信息和我的业务逻辑混到一起，这样和之前我们的原则违背，为了实现解耦和分离，我们需要了解服务降级！

​	修改microservicecloud-api工程，
​	根据已经有的DeptClientService接口新建一个实现了FallbackFactory接口的类DeptClientServiceFallbackFactory

```java
@Component
public class DeptClientServiceFallbackFactory implements FallbackFactory<DeptClientService>{

    @Override
    public DeptClientService create(Throwable throwable) {
        return new DeptClientService() {
            @Override
            public Dept get(long id) {
                Dept dept = new Dept();
                dept.setDeptno(id);
                dept.setDname("该ID：" + id + "没有没有对应的信息,null--@FallbackFactory");
                dept.setDb_source("DB_SOURCE");
                return dept;
            }

            @Override
            public List<Dept> list() {
                return null;
            }

            @Override
            public boolean add(Dept dept) {
                return false;
            }
        };
    }
}
```

![image-20200229153641148](%E4%B8%80.SpringCloud.assets/image-20200229153641148.png)

​						**千万不要忘记在类上面新增@Component注解**

​	修改microservicecloud-api工程，DeptClientService接口在注解@FeignClient中添加fallbackFactory属性值

```java
@FeignClient(value = "MICROSERVICECLOUD-DEPT",fallbackFactory = DeptClientServiceFallbackFactory.class)
public interface DeptClientService {
    @RequestMapping(value = "/dept/get/{id}", method = RequestMethod.GET)
    public Dept get(@PathVariable("id") long id);

    @RequestMapping(value = "/dept/list", method = RequestMethod.GET)
    public List<Dept> list();

    @RequestMapping(value = "/dept/add", method = RequestMethod.POST)
    public boolean add(Dept dept);

}
```

​	在microservicecloud-consumer-dept-feign工程修改YML配置文件，添加内容

```yml
feign: 
  hystrix: 
    enabled: true
```

​	![image-20200229153931488](%E4%B8%80.SpringCloud.assets/image-20200229153931488.png)

​	启动并测试，先起Eureka，在启动微服务microservicecloud-provider-dept-8001（并不是microservicecloud-provider-dept-hystrix-8001工程），microservicecloud-consumer-dept-feign启动并访问测试

![image-20200229154455260](%E4%B8%80.SpringCloud.assets/image-20200229154455260.png)

​	访问成功，关掉microservicecloud-provider-dept-8001工程模块，再次进行访问

![image-20200229154715355](%E4%B8%80.SpringCloud.assets/image-20200229154715355.png)

​	服务及降级成功，没有发生服务雪崩现象

###### 4）服务熔断服务降级总结

​	**服务熔断**

​	一般是某个服务故障或者异常引起，类似于现实世界中的保险丝，当某个异常条件被触发的时候，直接熔断整个服务，而不是一直等到此服务超时

​	有了熔断要有降级的原因：

​	SpringCloud两个重要的技术IOC和AOP，AOP就是相向切面的编程，说白了就是要将主业务跟异常处理做成一个切面，用植入的方式润物细无声的执行异常处理，也就是说业务逻辑中就**不应该带着这么多横切向的异常处理信息，实现主业务方法和异常处理方法解耦**，这是第一步，第二步就是要**避免方法膨胀，将所有的异常处理方法写一个接口进行统一的管理**

​	**服务降级**

​	所谓降级，一般是从整体复核考虑，就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值，这样做，虽然服务水平下降，但好歹可用，比直接挂掉强

###### 5）.服务监控hystrixDashboard（豪猪）

​	除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。

​	新建工程microservicecloud-consumer-hystrix-dashboard，参考其他的消费者工程

​	添加pom依赖

```xml
 <!-- hystrix和 hystrix-dashboard相关-->
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-hystrix</artifactId>
   </dependency>
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>
   </dependency> 
```

​	主启动类添加豪猪监控注解

```java
@SpringBootApplication
//新加监控注解
@EnableHystrixDashboard
public class DeptConsumer9001_DashBoard_App {
    public static void main(String[] args) {
   SpringApplication.run(DeptConsumer9001_DashBoard_App.class,args);
    }
}
```

​	配置文件端口改为9001

```yml
server:
  port: 9001
```

​	为所有的peovider  8001,8002,8003添加依赖

```xml
   <!-- actuator监控信息完善 -->
   <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-actuator</artifactId>
   </dependency>
```

​	先启动microservicecloud-consumer-hystrix-dashboard

​	直接进行访问：http://localhost:9001/hystrix

![image-20200229160933810](%E4%B8%80.SpringCloud.assets/image-20200229160933810.png)

​	先启动eureka集群，再启动microservicecloud-provider-dept-hystrix-8001

![image-20200229161414123](%E4%B8%80.SpringCloud.assets/image-20200229161414123.png)

​	访问没有问题

![image-20200229161806213](%E4%B8%80.SpringCloud.assets/image-20200229161806213.png)

​	Delay：该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，可以通过配置该属性来降低客户端网络和CPU消耗

​	Title：该参数对应了头部标题Hystrix  Stream之后的内容，默认会使用具体监控实例的URL，可以通过配置该信息来展示更合适的标题

![image-20200229161852930](%E4%B8%80.SpringCloud.assets/image-20200229161852930.png)

​	实心圆：共有两种含义，他通过颜色的变化代表了实例的健康程度，他的健康从绿色<黄色<橙色<红色递减，该实心圆出来了颜色的变化外，他的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大，所以通过该实心圆的展示，就可以在大量的实例中快速的发现故障实例和高压力实例

​	曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势。

![image-20200229161943118](%E4%B8%80.SpringCloud.assets/image-20200229161943118.png)

![image-20200229161952369](%E4%B8%80.SpringCloud.assets/image-20200229161952369.png)

​	根据豪猪监控，查看应用情况

##### 9.Zuul路由网关

​	Zuul包含了对请求的路由和过滤两个最主要的功能：
其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础.

​	Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。

​	注意：Zuul服务最终还是会注册进Eureka

​	官网资料：https://github.com/Netflix/zuul/wiki/Getting-Started

###### 1）新建模块

​	新建Module模块microservicecloud-zuul-gateway-9527

​	添加依赖

```xml
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-eureka</artifactId>
   </dependency>
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-zuul</artifactId>
   </dependency>
<!-- actuator监控 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <!-- hystrix容错 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-hystrix</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
    <!-- 日常标配 -->
    <dependency>
        <groupId>com.sinosoft.springcloud</groupId>
        <artifactId>microservicecloud-api</artifactId>
        <version>${project.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jetty</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
    </dependency>
    <!-- 热部署插件 -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>springloaded</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
    </dependency>
```

​	yml配置文件

```yml
server: 
  port: 9527
 
spring: 
  application:
    name: microservicecloud-zuul-gateway # 注册进Eureka的唯一标识名字
 
eureka: 
  client: 
    service-url: 
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka,http://eureka7003.com:7003/eureka  
  instance:
    instance-id: gateway-9527.com   # 需要改映射文件hosts
    prefer-ip-address: true 
 
 
info:
  app.name: atguigu-microcloud
  company.name: www.atguigu.com
  build.artifactId: $project.artifactId$
  build.version: $project.version$


```

​	将hosts文件新增映射：

```txt
127.0.0.1  myzuul.com
```

​	主启动类新加注解

```java
@SpringBootApplication
@EnableZuulProxy
public class Zuul_9527_StartSpringCloud_App {
    public static void main(String[] args) {
        SpringApplication.run(Zuul_9527_StartSpringCloud_App.class,args);
    }
}
```

​	启动Eureka集群，在启动一个简单的8001  provider，一个zuul模块

![image-20200229164341701](%E4%B8%80.SpringCloud.assets/image-20200229164341701.png)

​	集群中有两个微服务注册成功

​	不用路由进行访问：http://localhost:8001/dept/get/2

![image-20200229164503033](%E4%B8%80.SpringCloud.assets/image-20200229164503033.png)

​	启用路由：http://myzuul.com:9527/microservicecloud-dept/dept/get/2

![image-20200229164609491](%E4%B8%80.SpringCloud.assets/image-20200229164609491.png)

​	跳转访问成功！

###### 2）Zuul路由访问映射规则

​	此时已经暴露微服务名名称，进行遮掩

​	before
​	http://myzuul.com:9527/microservicecloud-dept/dept/get/2

```yml
zuul: 
  routes: 
    mydept.serviceId: microservicecloud-dept
    mydept.path: /mydept/**
```

​	after
​	http://myzuul.com:9527/mydept/dept/get/1

 ![image-20200229165139353](%E4%B8%80.SpringCloud.assets/image-20200229165139353.png)

 	遮掩成功！

​	但是原来的路径也是可以访问，进行处理，添加忽略信息

```yml
zuul:
  ignored-services: microservicecloud-dept # 需要忽略多个可以使用 ignored-services: "*" 
  routes:
    mydept.serviceId: microservicecloud-dept
    mydept.path: /mydept/**
```

​	使用原来的访问拒绝

![image-20200229165442594](%E4%B8%80.SpringCloud.assets/image-20200229165442594.png)

​	使用遮掩后访问成功

![image-20200229165502042](%E4%B8%80.SpringCloud.assets/image-20200229165502042.png)

​	还可以设置访问前缀

```yml
zuul:
  ignored-services: microservicecloud-dept
  prefix: /sinosoft
  routes:
    mydept.serviceId: microservicecloud-dept
    mydept.path: /mydept/**
```

​	访问网址：http://myzuul.com:9527/atguigu/mydept/dept/get/1

![image-20200229165725088](%E4%B8%80.SpringCloud.assets/image-20200229165725088.png)

​	访问成功！

##### 10.SpringCloudConfig分布式配置中心

###### 1)解决的问题

​	微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的，动态配置管理设施是不可少的，SpringCloud提供了ConfigServer来解决这个问题，每一个微服务自己带有application.yml，针对此进行统一管理

​	SpringCloud  Config分为服务端和客户端两部分，

​	服务端也称为分布式配置中心，他是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口	

​	客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息，配置服务器默认使用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容

优点：

 	1）集中式管理配置文件

​	 2）不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta

​	 3）运行期间动态调整配置，不在需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息

​	 4）当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置

​	 5）可以将配置信息以REST接口的形式暴露

###### 2）SpringCloudConfig服务端和Github通信

​	使用Github新建一个microservicecloud-config新的Repository，并复制SSH协议的git地址

![image-20191227101301348](%E4%B8%80.SpringCloud.assets/image-20191227101301348.png)

​	新建本地git仓库并clone



![image-20191227102006840](%E4%B8%80.SpringCloud.assets/image-20191227102006840.png)

​	在本地仓库中新建一个application.yml文件

```yml
spring:
  profiles:
    active:
    - dev

---
spring:
  profiles: dev    #开发环境
  application:
    name: microservicecloud-config-sinosoft-dev

---
spring:
  profiles: test   #测试环境
  application:
    name: microservicecloud-config-sinosoft-test

```

​	将上一步的yml文件推送到github上

![image-20191227122910887](%E4%B8%80.SpringCloud.assets/image-20191227122910887.png)

![image-20191227122925683](%E4%B8%80.SpringCloud.assets/image-20191227122925683.png)

​	新建module3344模块，添加注解

```java
@SpringBootApplication
@EnableConfigServer
public class Config_3344_StartSpringCloudApp {
    public static void main(String[] args) {
        SpringApplication.run(Config_3344_StartSpringCloudApp.class,args);
    }
}
```

​	hosts文件增加映射

```java
127.0.0.1 eureka7001.com
127.0.0.1 eureka7002.com
127.0.0.1 eureka7003.com

127.0.0.1 myzuul.com

127.0.0.1 config-3344.com
```

​	启动并访问yml

![image-20191227143413236](%E4%B8%80.SpringCloud.assets/image-20191227143413236.png)

​	实现了动态的从github上面获取配置信息的过程

###### 3）客户端Consumer配置和测试

新建配置yml文件并上传到github上

```yml
spring:
  profiles:
    active:
    - dev

---
server:
  port: 8201
spring:
  profiles: dev    #开发环境
  application:
    name: microservicecloud-config-client
eureka:
  client:
    server-url:
      defaultZone: http://eureka-dev.com:7001/eureka
---
server:
  port: 8202
spring:
  profiles: test    #测试环境
  application:
    name: microservicecloud-config-client
eureka:
  client:
    server-url:
      defaultZone: http://eureka-test.com:7001/eureka


```

![image-20191229203516095](%E4%B8%80.SpringCloud.assets/image-20191229203516095.png)

​	新建microservicecloud-config-client-3355模块工程

​	新建bootstrap.yml文件

​	PS：

​		application.yml文件是用户级的资源配置项

​		bootstrap.yml是系统级的,优先级更高

​		SpringCoud会创建一个Bootstrap  Context，作为Spring应用的Application  Context的父上下文，初始化的时候,Bootstrap  Context负责从外部源加载配置属性并解析配置，这两个上下文共享一个从外部获取的Environment，Bootstrap  属性有较高的优先级，默认情况下，他们不会被本地文件覆盖



​	bootstrap.yml文件内容：

```yml
spring: # 通过3344的工程来获取指定文件名的配置文件 
  cloud:
    config:
      name: microservicecloud-config-client  # 需要从github上读取的资源名称(
      profile: dev # 本次访问的配置项
      label: master
      uri: http://config-3344.com:3344 # 本次微服务启动之后先去找3344服务
      # 通过SpringCloudConfig获取Github的服务网址
```

​	新建application.yml文件：

```yml
spring:
  application:
    name: microservicecloud-config-client
```

​	编写验证代码：

```java
@RestController
public class ConfigClientRest {
    @Value("${spring.application.name}")
    private String applicationName;

    @Value("${eureka.client.service-url.defaultZone}")
    private String eurekaServers;

    @Value("${server.port}")
    private String port;

    @RequestMapping("/config")
    public String getConfig()
    {
        String str = "applicationName: " + applicationName + "\t eurekaServers:" + eurekaServers + "\t port: " + port;
        System.out.println("******str: " + str);
        return "applicationName: " + applicationName + "\t eurekaServers:" + eurekaServers + "\t port: " + port;
    }
}

```

​	测试！

​	先启动3344Config配置中心并自测

​	在启动3355测试

![image-20191229211453033](%E4%B8%80.SpringCloud.assets/image-20191229211453033.png)

​	测试通过！



