#### 一.Redis常见缓存问题

##### 1.缓存穿透

​	key对应的数据在数据源并不存在，每次针对于此key的请求从缓存中取不到值，请求都会到数据源，从而压垮数据源

​	解决方式：如果一个数据查询为空（不管数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但是过期时间很短，最长不超过5分钟

##### 2.缓存雪崩

​	当Redis服务器重启或者大量缓存在同一时期失效时,此时大量的流量会全部冲击到数据库上面,数据库有可能会因为承受不住而宕机

​	解决方式：

​		均匀分布：我们应该在设置失效时间时尽量均匀

https://zhuanlan.zhihu.com/p/58265935

##### 3.缓存击穿

​	key对应的数据存在，但是在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般会从后端数据库数据源加载数据并回设到缓存中，这个时候大并发的请求可能会瞬间把后端DB压垮

​	（也就是说在某些时间某个key被超高并发的访问）

​	解决方式：使用互斥锁（mutex  key），在缓存失效的时候（判断此时从Redis缓存中拿到的值为空），并不直接去数据库中进行查询，而是使用带成功返回操作值的操作（例如Redis的setnx或者Memcache的add）去set一个标识位的值，当操作返回成功的时候，再进行查询数据库的操作，这样就保证了高并发的情况下，只有一个线程会获取数据库的连接进行数据查询，返回失败则重试整个get缓存方法

​	setnx，是  set if  not exists 的缩写，也就是说只有在不存在的时候才设置，可以用这个来实现锁的效果

```java
public String get(key) {
      String value = redis.get(key);
      if (value == null) { //代表缓存值过期
          //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
      if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
               value = db.get(key);
                      redis.set(key, value, expire_secs);
                      redis.del(key_mutex);
              } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
                      sleep(50);
                      get(key);  //重试
              }
          } else {
              return value;      
          }
 }
```

```java

if (memcache.get(key) == null) {  
    // 3 min timeout to avoid mutex holder crash  
    if (memcache.add(key_mutex, 3 * 60 * 1000) == true) {  
        value = db.get(key);  
        memcache.set(key, value);  
        memcache.delete(key_mutex);  
    } else {  
        sleep(50);  
        retry();  
    }  
}
```

