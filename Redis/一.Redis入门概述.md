#### 一.Redis入门概述

​	3V+3高：

​		大数据时代的3V  ：海量Volume  多样Variety  实时Velocity

​		互联网需求的三高：高并发  高可扩  高性能

![1565500517470](E:\Typora笔记\Pic\1565500517470.png)

##### 1.传统的ACID 

​	A:原子性

​		事务的所有操作要么全部做完，要么都不做，事务成功的条件是事务所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚

​	C：一致性

​		数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束

PS：

作者：孟波
链接：https://www.zhihu.com/question/31346392/answer/362597203
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



比较支持

[@Kai Peng](http://www.zhihu.com/people/75e3cff99a8f2c29e78133d7cc761614)

 的答案,只是缺少例子说明. 而其他一些人的答案甚至有明显的错误.最近正好也在研究这方面的东西,不算是回答,就是跟大家讨论讨论.



首先,我们需要搞清楚为什么会出现事务.

> [1]Transactions are not a law of nature; they were created with a purpose, namely to simplify the programming model for applications accessing a database. By using transactions, the application is free to ignore certain potential error scenarios and concurrency issues, because the database takes care of them instead (we call these safety guarantees).

这句话的大体含义就是,事务的产生,其实是为了当应用程序访问数据库的时候,事务能够简化我们的编程模型,不需要我们去考虑各种各样的潜在错误和并发问题.可以想一下当我们使用事务时,要么提交,要么回滚,我们不会去考虑网络异常了,服务器宕机了,同时更改一个数据怎么办对吧?**因此事务本质上是为了应用层服务的**.而不是伴随着数据库系统天生就有的.

其次,说道一致性,很遗憾,这个词在不同的环境下有着不同的含义,被极大的滥用了,导致很难理解:

> \1. 多副本的一致性
> \2. 一致性hash.
> \3. CAP理论的一致性
> \4. ACID里的一致性

而这几个一致性的含义都

**不是一回事!**

**不是一回事!**

**不是一回事!**

**所有提到最终一致性,一致读的回答,都是不对的**,那是CAP里面C的含义,具体可以搜索查询**Linearizability** 这个词的含义,这个并不是今天的重点.



然后回到问题!!!

楼主提到了ACID,那么我们就可以简化问题单机场景下事务里一致性的含义,为什么不讨论分布式呢?因为既然一个分布式数据库提供了ACID事务保证,那么你把它看做单机又何妨呢?它是如何做到如同单机一般的,我们根本不需要关心啊.所以只考虑单机能够简化楼主的思维.

**ACID里的AID都是数据库的特征,也就是依赖数据库的具体实现.而唯独这个C,实际上它依赖于应用层,也就是依赖于开发者.这里的一致性是指系统从一个正确的状态,迁移到另一个正确的状态.什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态.而事务具备ACID里C的特性是说通过事务的AID来保证我们的一致性.**

> **做个比喻事务就好比一个保镖,我们提到事务就会说ACID,而我们提到保镖会说强壮,保护安全,好功夫,踏实.这里强壮,好功夫和踏实都是保镖自己的特征,而安全是属于你的,而你通过保镖的特征来保护你的安全.**

但是这里必须注意,我们能够通过AID保证我们的一致性,但事务本身没办法确保.用上面保镖的例子来说,你正常被保护一定是安全的,但是你故意骗保镖离开你身边,然后你自己溜出去玩.同样,如果你在事务里故意写出违反约束的代码,比如银行系统定时每天给自己的账户打入100w,这个事务是没办法的.



这里我们举个大家都在说的财务系统的例子.

> A要向B支付100元,而A的账户中只有90元,并且我们给定账户余额这一列的约束是,不能小于0.那么很明显这条事务执行会失败,因为90-100=-10,小于我们给定的约束了.

这个例子里,支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证.然后我们再看个例子

> A要向B支付100元,而A的账户中只有90元,我们的账户余额列没有任何约束.但是我们业务上不允许账户余额小于0.因此支付完成后我们会检查A的账户余额,发现余额小于0了,于是我们进行了事务的回滚.

这个例子里,如果事务执行成功,虽然没有破坏数据库的约束,但是破坏了我们应用层的约束.而事务的回滚保证了我们的约束,因此也可以说事务提供了一致性保证(ps:事实上,是我们应用层利用事务回滚保证了我们的约束不被破坏).最后我们再看个例子

> A要向B支付100元,而A的账户中只有90元,我们的账户余额列没有任何约束.然后支付成功了.

这里,如果按照很多人的理解,事务不是保证一致性么?直观上账户余额为什么能为负呢.但这里事务执行前和执行后,我们的系统没有任何的约束被破坏.一直都是保持正确的状态.

所以,综上.你可以理解一致性就是:应用系统从一个正确的状态到另一个正确的状态.而ACID就是说事务能够通过AID来保证这个C的过程.C是目的,AID都是手段.

回答里肯定有诸多有误的地方,希望大神们能够指正~

​	 I：独立性

​		并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另一个事务修改，只要另外一个事物未提交，他所访问的的数据就不会受未提交的事务的影响

​	 D:持久性

​		一旦事务提交后，他所做的修改就会永久的保存在数据库上，即使出现宕机也不会丢失

##### 2.Nosql的三大特性

​	C：Consistency	强一致性

​	A：Availability	可用性

​	P：Partiton tolerance	分区容错性

​	CAP理论在我们的分布式存储系统中，最多只能实现上面的两点

​	而由于当前的网络硬件肯定会出现延迟丢包等问题，所以

​	**分区容忍性是我们必须要实现的**



​	所以我们只能在一致性和可用性之间进行权衡，没有NoSql系统能同时保证这三点

​		CA:传统的Oracle数据库

​		AP:大多数网站架构的选择

​		CP:Redis	Mongodb

​		BASE就是为了解决关系型数据库强一致性引起的可用性降低而提出的方案

​		BASE缩写：

​			基本可用（Basically  Available）

​			软状态（Soft  state）

​			最终一致（Eventually consistent）

​		他的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上的改观，大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，想要获得这些指标，我们必须采用另外一种方式来完成，BASE就是解决这个问题的办法

​		分布式：不同的多台服务器上面部署不同的服务模块，他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作

​		集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问







